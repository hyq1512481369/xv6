diff --git a/Makefile b/Makefile
index d8509b1..7c258af 100644
--- a/Makefile
+++ b/Makefile
@@ -175,6 +175,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_symlinktest\
 
 
 
diff --git a/grade-lab-fs b/grade-lab-fs
index f1762e1..cccf94c 100755
--- a/grade-lab-fs
+++ b/grade-lab-fs
@@ -9,7 +9,7 @@ r = Runner(save("xv6.out"))
 def test_bigfile():
     r.run_qemu(shell_script([
         'bigfile'
-    ]), timeout=180)
+    ]), timeout=600)
     r.match('^wrote 65803 blocks$')
     r.match('^bigfile done; ok$')
 
@@ -31,7 +31,7 @@ def test_symlinktest_symlinks():
 def test_usertests():
     r.run_qemu(shell_script([
         'usertests'
-    ]), timeout=360)
+    ]), timeout=600)
     r.match('^ALL TESTS PASSED$')
 
 @test(1, "time")
diff --git a/kernel/fcntl.h b/kernel/fcntl.h
index 44861b9..22e7290 100644
--- a/kernel/fcntl.h
+++ b/kernel/fcntl.h
@@ -3,3 +3,4 @@
 #define O_RDWR    0x002
 #define O_CREATE  0x200
 #define O_TRUNC   0x400
+#define O_NOFOLLOW  0x004
diff --git a/kernel/file.h b/kernel/file.h
index b076d1d..5c4eb3a 100644
--- a/kernel/file.h
+++ b/kernel/file.h
@@ -26,7 +26,7 @@ struct inode {
   short minor;
   short nlink;
   uint size;
-  uint addrs[NDIRECT+1];
+  uint addrs[NDIRECT+2];
 };
 
 // map major device number to device functions.
diff --git a/kernel/fs.c b/kernel/fs.c
index f33553a..ff390fb 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -401,6 +401,33 @@ bmap(struct inode *ip, uint bn)
     return addr;
   }
 
+  //mine
+  bn -= NINDIRECT;
+  if(bn < NDOUBLYINDIRECT) {
+    // 获取两次块的地址
+    if((addr = ip->addrs[NDIRECT + 1]) == 0) {
+      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
+    }
+    bp = bread(ip->dev, addr);
+    a = (uint*)bp->data;
+    // 获取一次块的地址
+    if((addr = a[bn / NINDIRECT]) == 0) {
+      a[bn / NINDIRECT] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    bp = bread(ip->dev, addr);
+    a = (uint*)bp->data;
+    bn %= NINDIRECT;
+    // 获取直接块的地址
+    if((addr = a[bn]) == 0) {
+      a[bn] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    return addr;
+  }
+
   panic("bmap: out of range");
 }
 
@@ -409,9 +436,9 @@ bmap(struct inode *ip, uint bn)
 void
 itrunc(struct inode *ip)
 {
-  int i, j;
-  struct buf *bp;
-  uint *a;
+  int i, j, k;  //添加k
+  struct buf *bp, *bp2;     //添加bp2
+  uint *a, *a2; //添加a2
 
   for(i = 0; i < NDIRECT; i++){
     if(ip->addrs[i]){
@@ -431,6 +458,28 @@ itrunc(struct inode *ip)
     bfree(ip->dev, ip->addrs[NDIRECT]);
     ip->addrs[NDIRECT] = 0;
   }
+  // 释放二次块
+  if(ip->addrs[NDIRECT + 1]) {
+    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
+    a = (uint*)bp->data;
+    for(j = 0; j < NINDIRECT; ++j) {
+      if(a[j]) {
+        bp2 = bread(ip->dev, a[j]);
+        a2 = (uint*)bp2->data;
+        for(k = 0; k < NINDIRECT; ++k) {
+          if(a2[k]) {
+            bfree(ip->dev, a2[k]);
+          }
+        }
+        brelse(bp2);
+        bfree(ip->dev, a[j]);
+        a[j] = 0;
+      }
+    }
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT + 1]);
+    ip->addrs[NDIRECT + 1] = 0;
+  }
 
   ip->size = 0;
   iupdate(ip);
diff --git a/kernel/fs.h b/kernel/fs.h
index 139dcc9..6f2ac3e 100644
--- a/kernel/fs.h
+++ b/kernel/fs.h
@@ -24,9 +24,9 @@ struct superblock {
 
 #define FSMAGIC 0x10203040
 
-#define NDIRECT 12
+#define NDIRECT 11
 #define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
+#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLYINDIRECT)
 
 // On-disk inode structure
 struct dinode {
@@ -35,7 +35,7 @@ struct dinode {
   short minor;          // Minor device number (T_DEVICE only)
   short nlink;          // Number of links to inode in file system
   uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
+  uint addrs[NDIRECT+2];   // Data block addresses
 };
 
 // Inodes per block.
@@ -57,4 +57,6 @@ struct dirent {
   ushort inum;
   char name[DIRSIZ];
 };
-
+#define NDOUBLYINDIRECT (NINDIRECT * NINDIRECT) 
+// 最大深度 ，mine
+#define MAXLINK 10
diff --git a/kernel/stat.h b/kernel/stat.h
index 19543af..5ed89f0 100644
--- a/kernel/stat.h
+++ b/kernel/stat.h
@@ -1,6 +1,7 @@
 #define T_DIR     1   // Directory
 #define T_FILE    2   // File
 #define T_DEVICE  3   // Device
+#define T_SYMLINK 4 //mine
 
 struct stat {
   int dev;     // File system's disk device
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..d9a5af0 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_symlink(void);  //mine
 
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_symlink] sys_symlink, //mine
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..b533e5e 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_symlink 22 //mine
\ No newline at end of file
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..2dff73c 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -283,6 +283,43 @@ create(char *path, short type, short major, short minor)
   return ip;
 }
 
+static struct inode* follow_symlink(struct inode* ip) {
+  uint inums[MAXLINK];
+  int i, j;
+  char target[MAXPATH];
+
+  for(i = 0; i < MAXLINK; i++) {
+    inums[i] = ip->inum;
+    // 读文件
+    if(readi(ip, 0, (uint64)target, 0, MAXPATH) <= 0) {
+      iunlockput(ip);
+      printf("open_symlink: open symlink failed\n");
+      return 0;
+    }
+    iunlockput(ip);
+    
+    // 找inode
+    if((ip = namei(target)) == 0) {
+      printf("open_symlink: path \"%s\" not exist\n", target);
+      return 0;
+    }
+    for(j = 0; j <= i; ++j) {
+      if(ip->inum == inums[j]) {
+        printf("open_symlink: links  cycle\n");
+        return 0;
+      }
+    }
+    ilock(ip);
+    if(ip->type != T_SYMLINK) {
+      return ip;
+    }
+  }
+
+  iunlockput(ip);
+  printf("open_symlink: depth  limited\n");
+  return 0;
+}
+
 uint64
 sys_open(void)
 {
@@ -321,6 +358,15 @@ sys_open(void)
     end_op();
     return -1;
   }
+  // mine
+  if(ip->type == T_SYMLINK && (omode & O_NOFOLLOW) == 0) {
+    if((ip = follow_symlink(ip)) == 0) {
+      // 此处好像不用释放锁,注释掉了
+      //iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
 
   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
     if(f)
@@ -484,3 +530,33 @@ sys_pipe(void)
   }
   return 0;
 }
+
+
+uint64 sys_symlink(void) {
+  int n;
+  char target[MAXPATH];
+  struct inode *node;
+  char path[MAXPATH];
+
+  if ((n = argstr(0, target, MAXPATH)) < 0 || argstr(1, path, MAXPATH) < 0) {
+    return -1;
+  }
+  begin_op();
+  //创建inode
+  if((node = create(path, T_SYMLINK, 0, 0)) == 0) {
+      end_op();
+      return -1;
+  }
+  //写target
+  if(writei(node, 0, (uint64)target, 0, n) != n) {
+    iunlockput(node);
+    end_op();
+    return -1;
+  }
+  iunlockput(node);
+  end_op();
+  return 0;
+}
+
+
+
diff --git a/user/user.h b/user/user.h
index b71ecda..3db5696 100644
--- a/user/user.h
+++ b/user/user.h
@@ -40,3 +40,4 @@ void free(void*);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+int symlink(char *,char *);  //mine
\ No newline at end of file
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..a8d7e51 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("symlink");  #mine
